<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<script type="text/javascript">
/*
Objects come in two forms: the declartive (literal) form and the constructed form.

The literal syntax for an object looks like this:
*/

var myObj = {
      key:value;
      //..
};

/* The constructed form looks like this: */

var myObj2 = new Object();
myObj2.key = value;

/* The constructed form and the literal form result in exactly the same sort of
object. The only difference really is that you can add one or more key/values
pairs to the literal declaration, whereas with constructed-form objects, you
must add the properties one-by-one.

NOTE: It's extremely uncommon to use the "constructed form" for creating objects
as just shown. You would pretty much always want to use the literal synatax form.
The same will be true of most of the built-in objects.
*/

/*TYPE */

/* Objects are the building blocks upon which JS was built. They are one of the
six primary types (called "language types" in the specs) in JS:

1. string
2. number
3. boolean
4. null
5. undefined
6. object

Note that simple primatives (string, number, boolean, null and undefined) are
NOT themselves objects. null is sometimes referred to as an object type, but this
misconception stems from a bug in the language which causes typeof null to return
the string "object" incorrectly (and confusingly).
In fact, null is its own primitive type.

It's a common mis-statement that "everything in JS is an object".
This is clearly not true.

By contrast there are a few special object sub-types, which we can refer to as
complex primitives.

<code>function</code> is a sub-type of an object (technically, a "callable object").
Functions in JS are saud to be "first class" in that they are bascially just normal
objects (with callable behaviour semantics bolted on), ad=nd so they can be handled
like any other plain object.

Arrays are also a form of objects, with extra behavour. The organisation of contents
in arrays is slightly more stuctured than for general objects.

<h3>Built-in Objects</h3>
There are serveral object sub-types, usually referred to as built-in objects.
For some of them, their names seem to imply that they are directly related to
their simple primitives counter-parts, but in fact, their relationship, is more
complicated, which we'll explore shortly.

<ul>
<li>String</li>
<li>Number</li>
<li>boolean</li>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
</ul>

These built-in have the appearance of being actual types, even classes, if you rely
on the simlarity to other languages such as Java's <code>string</code> class.

But in JS, these are actually built in functions. Each of these built-in functions
can be used as a constructor ( that is, a function call with the new operator ),
with the result being a newly constructed object of the sub-type in question.
For example: */

var strPrimitive = "I am a string";
typeof strPrimitive;                              // "string"
strPrimitive instanceof String;                   // false

var  strObject = new String( "I am a string" );
typeof strObject;                                 // "object"
strObject instanceof String;                      // true

//inspect the object sub-type
Object.prototype.toString.call( strObject );      // [object String]

/*
The primitive value "I am a string" is not an object, its a primitive literal and
immutable value. To perform operations on it, such as checking its length, accessing
its individual character contents, etc a <code>String</code> object is required.

Lucky the language automatically coerces a "string" primitive to a String object
when necessary, which means you almost never need to explicitly create the Object form.
It is <em>strongly preferred</em> by the majority of the JS community to use the
literal form for a value where possible, rather than the constructed object form.
*/

var strPrimitive = "I am string";

console.log( strPrimitive.length );         // 13

console.log ( strPrimitive.charAt( 3 ) );   // "m"

/*
In both cases, we call a property or method on a strong primitive, and the engine automatically
coerces it to a <code>string</code> object, so that the property/method access works.

The same sort of coercion happen between the number literal primitive <code>42</code> and the
<code>new number(42)</code> object wrapper, when using methods like <code>42.359.toFixed(2)</code>.
Likewise for <code>boolean</code>  objects from <code>"boolean"</code> primitves.

null and undefined have no object wrapper form, only their primitive values. By
contrast, Date Values can only be created with their constructed form, as they have no literal
form counter-part.

Object S, Array s, Function s and RegExp s are all objects regardless of whether the literal or
constructed form is used. The constructed form does offer in some cases, more options in creation
than the literal form counterpart. Since objects are created either way, the simpler literal form is
almost universally preferred.<em> Only use the constructed form if you need the extra options.</em>

<code>Error</code> objects are rarely created with the constructed form new Error(..), but it's often
unnecessaary.

<h3>Contents</h3>
The contents of an object consist of values (any type) stored at specifically named locations,
which we call properties.

It's important to note that while we say "contents" which implies that these values are actually
stored inside the object, that's merely an appearance. The engine stores values in
implementation-dependent ways, and may very well not store them in some object container. What is
stored in the container are those property names, which act as pointers (technically, references)
to where the values are stored.
*/

var myObject = {
      a:2
};

myObject.a;       // 2    "property access"
myObject["a"];    // 2    "key access"

/*
To access the value at the location a in myObject, we need to use either the . operator or the
[ ] operator. The .a syntax is usually referred to as "property" access, whereas the ["a"] syntaz
is usually reffered to as "key" access. In reality, the both access the same location, and will
pull out the same value, 2, so the terms can be used interchangeably. We will use the most common
term, "property access" from here on.

The difference between the two syntaxes is that the <code>.</code> operator requires an Identifer
compatible property name after it, whereas the <code> [".."]</code> syntax can take basically any
UTF-8/unicode compatible string as the name for the property. To reference a property of the name
"Super-Fun!", for instance, you would have to use the <code>["Super-Fun1"] access syntax, as
<code>Super-Fun!</code> is not a valid <code> Identifer</code> property name.

Since the <code>[".."] syntax uses a string's value to specify the location, this means the program
can programmatically build up the value of the string, such as:
*/

var wantA = true;
var myObject = {
  a:2
};

var idx;

if (wantA) {
  idx = "a";
}

//later

console.log( myObject[idx] ); // 2

/*
In objects, property names are always strings. If you use any other value besides <code>string</code>
(primitive) as the property, it will first be converted to a string. this even includes numbers, which
are commonly used as array indexes, so be careful not to confused the use of numbers between objects
and arrays.
*/

var myObject = { };

myObject[true] = "foo";
myObject[3] = "bar";
myObject[myObject] = "baz";

myObject["true"];             //"foo"
myObject["3"];                //"bar"
myObject["[object Object]"];  //"baz"

/*
<h3>Computed Property Names</h3>

The <code>myObject[..]</code> property syntax we just described is useful if you need to used a
computed expression value as the key name, like <code>myObject[prefix + name]</code>. But that's not
really helpful when declaring objects ising the object-literal syntax.

ES6 adds computed property names, where you can specify an expression, surrounded by a <code>[ ]</code> pair,
in the key-name position of an object-literal declaration.
*/

var prefix ="foo";

var myObject = {
  [prefix + "bar"]: "hello",
  [prefix + "baz"]: "world"

};

myObject["foobar"];           // hello
myObject["foobaz"];           // world

/*
The most common usuage of computed property names will be probably ES6 <code>symbol</code> s, which we will
not be covering in detail in this book. In short, they're a new primitive data type which has an transparent
unguessable value (technically a <code>string</code> value). You will be strongly discouraged from working
with the actual value of a <code>symbol</code> (which can theoretically be different between different JS engines),
so the name of the <code>Symbol</code>, like <code>Symbol.Something</code> (just a made up name!), will be what
you use:
*/
var myObject = {
  [Symbol.Something]: "hello world!"
};

/*
<h3>Property vs. Method</h3>
Some developers like to make a distinction when talking about a property access on an object, if the value being
accessed happens to be a function. Because it's tempting to think of the function as belonging to the object, and
in other languages, functions which belong to objects (aka classes) are referred to as "methods", it's not uncommon
to hear, "method access" as opposed to "property access"

<em>The specification makes this same distinction</em>, interestly.

It is true that some functions have <code>this</code> references in them, and that sometimes these <code>this</code>
references refer to the object reference at the call-site. But this usuage really does not make that function any more
"method" than any other function, as <code>this</code> is dynamically bound at run-time, at the call-site, and this
its relationship to the object is indirect, at best.

Everytime you access a property on an object, that is a <em>property access</em>, regardless of the type of
value you get back. If you happen to get a function from that property access, it's not magically a "method"
at that point. There's nothing special (outside of possible implicit <code>this</code> binding as explained earlier)
about a function that comes from a property access.
*/

function foo() {
  console.log("foo");

}

var someFoo = foo;

var myObject = {
    someFoo:foo
};

foo;                // function foo(){..}

someFoo;            // function foo(){..}

myObject.someFoo;   // function foo(){..}

/*
someFoo and myObject.someFoo are just two separate references to the same function,
and neither is implies anything about the function being special or "owned" by any
other object. If <code>foo()</code> above was defined to have a <code>this</code>
reference inside it, that <code>myObject.someFoo</code> implicit binding would be
the only observable difference between the two references. Neither reference really
makes sense to be called a "method".

<em>Perhaps one could argue</em> that a function becomes a method, not a definition time,
but during run-time just for that invocation, depending on how it's called at it's
call-site (with an object reference context or not). Even this interpretation is abit of
stretch.

The safest conclusion is probably that "function" and "method" are interchangeable in JS.

Note: ES6 adds a <code>super</super> reference, which is typically going to be used with
<code>class</code>. The way <code>super</code> behaves (static binding rather than late
binding as <code>this</code>) gives further insight to the idea that a function which is
super bound somewhere is more a "method" than a "function". But again, these are just
subtle semantic (and mechanical) nuances.

Even when you declare a function expression as part of the object-literal, that function
doesn't magically belong more to the object - still just multiple references to the same
function object:
*/

var myObject ={
    foo:function foo(){
      console.log("foo");
    }
};

var someFoo = myObject.foo;

someFoo;                      // function foo(){..}

myObject.foo;                 // function foo(){..}

/*
<h3> Arrays </h3>

Arrays also use the <code>[ ]</code> access form, but as mentioned above, they have slightly
more structured organization for how and where values are stored (though still no restriction
on what type of values are stored). Array assume numeric indexing, which means that values
are stored in locations, usually called indices, at non-negative intergers, such as <code>0</code>
and <code>42</code>
*/

var myArray = ["foo", 42, "bar"];

myArray.length;               // 3

myArray[0];                   // "foo"

myArray[2];                   // "bar"

/*
Arrays are objects, so even though each index is a positive integer, you can also add
properties onto the array:
*/

var myArray = [ "foo", 42, "bar"];

myArray.baz = "baz";

myArray.length;                 // 3
console.log(myArray.length);

myArray.baz                     // "baz"

/* Notice that adding named properties (regardless of . or [] operator syntax) does not
change the reported length of the array.

You could use an array as plain key/value object, and never add any numeric indices, but
this is a bad idea because arrrays have behavour and optimization speicific to their intended
use, and likewise with plain objects. Use objects to store key/value pairs, and arrays to
store values at numeric indices.

<em>Be careful</em>: If you want to add a property to an array, but the property name looks
like a number, it will end up instead as a numeric index (thus modifying the array contents):
*/

var myArray = [ "foo", 42, "bar"];

myArray["3"] = "baz";

myArray.length;                   // 4

myArray[3];                       // "baz"

/*
<h3> Duplicating Objects </h3>
One of the most commonly requested features when devs take up newly JS langugage
is how to duplicate an object. It would seem like there should be a built-in
<code>copy()</code> method, right? It turns ot that it;s a little more complicated
than that, because it's not fully clear what, by default, should be the algorithm
for duplication.

For example:
*/

function anotherFunction() { /*..*/ }

var anotherObject = {
  c:true
};

var anotherArray = [];

var myObject = {
  a:2,
  b: anotherObject,
  c: anotherArray,
  d: anotherFunction
};

anotherArray.push( anotherObject, myObject)

/*
What exactly should be the representation of a copy <code>myObject</code>?

Firstlym we should answer if it should be a shallow or deep copy. A shallow copy
would end up with <code>a</code> on the new object as a copy of the value <code>2</code>,
but <code>b, c, and d </code> propertiesas just references to the same places as the references
in the original object.

A deep copy would duplicate not only <code>myObject</code>, but anotherObject and anotherArray.
But then we have issues that anotherArray has references to anotherObject and myObject in it, so
those should also be duplicated rather than reference preserved. Now we have infinite circular
duplication problem because of the circular reference.

Should we detect circular reference and just break the circular traversal
(leaving the deep element not fully duplicated)? Should we error out completely? Something in between?

It is also noted that there isn't clear definition of what "duplicating" a function would mean?
There are some hacks like pulling out the <code>toString()</code> serialization of a function's
source code (which varies across implementations and is not even reliable in all engines depending
on the type of function being inspected).

So how do we resolve these tricky questions? Various JS frameworks have each picked their own
interpretations and made their own decisions. But which of these (if any) should JS adopt as the
standard? For a long time, there was no clear answer.

One subset solution is that objects which are JSON-safe (that is, can be serialized to JSON string and
then re-parsed to an object with the same structure and values) can easily be duplicated with:
*/
var newObj = JSON.parse( JSON.stringify( someObj ) );

/*
Of course, that requires you to ensure your object is JSON safe. For some situations, that's trivial.
For others, it's insuffient.

At the same time, a shallow copy is fairly understandable and has far less issues, so ES6 has now defined
<code>Object.assign(..)</code> for this task. <code>Object.assign(..)</code> takes a target object as its
first parameter, and one or more source objects as its subsequent parameters. It iterates over all the
enumberable (see below), owned keys(immediately present) on the source object(s) and copies them
(via = assignment only) to target. It also, hopefully, returns target as you can see below:
*/

var newObj = Object.assign( {}, myObject );

newObj.a;
newObj.b === anotherObject;     // true
newObj.c === anotherArray;      // true
newObj.d ===another function    // true

/*
Note: In the next section, we describe "property descriptors" (property characteristics) and show the use of
<code>Object.defineProperty(..)</code>. The duplication that occurs for <code>Object.assign(..)</code> however
is purely = style assignment, so any special characteristics of a property (like <code>writeable</code>) on a
source object are not preserved on the target object.
*/

/*
<h3>Property Descriptors</h3>

Prior to ES5, the JS lang gave no direct way for your ode to inspect or draw any distinction between the
characteristics of properties, such as whether the property was read-only or not.

But as of ES5, all properties are described in terms of a property descriptor.

Consider this code:
*/

var myObject = {
  a:2
};

Object.getOwnPropertyDescriptor( myObject, "a" );
// {
//    value: 2,
//    writable: true,
//    enumberable: true,
//    configurable: true
//}

/*
As you can see, the property descriptor (called a "data descriptor" since it's only for holding a data value)
for our normal object property <code>a</code> is much more than just its <code>value</code> of <code>2</code>.
It includes 3 other characteristics: <code>writable</code>, <code>enumberable</code> and <code>configurable</code>

While we can see what the default values for the property descriptor characteristics are when we create a normal
property, we can use the <code>Object.defineProperty(..)</code> to add a new property, or modify an existing one
(if it's <code>configurable</code>!), with the desired characteristics.

For example:
*/

var myObject {};

Object.defineProperty( myObject, "a", {
      value: 2,
      writable: true,
      configurable: true,
      enumberable:true
} );

myObject.a;     // 2

/*
Using the <code>defineProperty(..), we added the plain, normal <code>a</code> property to <code>myObject</code> in
a manually explicit way. However, you generally wouldn't use this manual approach unless you wanted to modify
one of the descriptor characteristics from its normal behavour.

<em>Writable</em>

You can see that the value was not writen to the object as we have PropertyDescriptor writable: false,
preventing the myObject.a = 3; from writing to the myObject

*/

var myObject {};

Object.defineProperty( myObject, "a", {
      value: 2,
      writable: false,
      configurable: true,
      enumberable:true
} );

myObject.a = 3;

myObject.a;     // 2

/*
As you can see, our modifcation of the <code>value</code> silently failed. If we try in <code>strict mode</cod>,
we get an error */

"use strict"
var myObject {};

Object.defineProperty( myObject, "a", {
      value: 2,
      writable: false, //not writable
      configurable: true,
      enumberable:true
} );

myObject.a = 3; //TypeError

/*
The TypeError tells us that we cannot change a non-Writable property.

Note: We will discuss getters/setters shortly, but briefly, you can observe that
<code>writable: false</code>

<em>Configurable</em>
As long as a property is currently configurable, we can modify its descriptor definition,
using the same defineProperty(..) utility.


// need to remove above's "use strict"
*/

var myObject {
  a:2

};

myObject.a = 3;
myObject.a;

Object.defineProperty( myObject, "a", {
      value: 4,
      writable: false, //not writable
      configurable: false,
      enumberable:true
} );

myObject.a;
myObject.a = 5;
myObject.a;

Object.defineProperty( myObject, "a", {
      value: 6,
      writable: true, //not writable
      configurable: true,
      enumberable:true
} ); //TypeError
/*
The final defineProperty(..) call results in a TypeError, regardless of <code>strict mode</code>,
if you attempt to change the descriptor definition of a non-configuable property.
Be careful: as you can see, changing <code>configuable</code> to <code>false</code> is a
<b>one-way action, and cannot be undone!</b>

Note: There's a differing exception to be aware of: even if the property is already
<code>configurable:false</code>, <code>writable</code> can always be changed from <code>true</code>
to <code>false</code> without error, but not back to <code>true</code> if already <code>false</code>

Another interesting thing is that <code>configurable:false</code> prevents the use of <code>delete</code>
operator to remove an existing property.
*/

var myObject = {
	a: 2
};

myObject.a;				// 2
delete myObject.a;
myObject.a;				// undefined

Object.defineProperty( myObject, "a", {
	value: 2,
	writable: true,
	configurable: false,
	enumerable: true
} );

myObject.a;				// 2
delete myObject.a;    //FAILS
myObject.a;	      // 2

/*

As you can see, the last <code>delete</code> call failed (silently) because we meade the <code>a</code>
property non-configurable.

<code>delete</code> is only used to remove object properties (which can be removed) directly
from the object in question. If an object property is the last remaining reference to some object/function
and you <code>delete</code> it, that removes the reference and now that unreferenced object/function can
be garbage collected. But it is <b>not</b> proper to think of <code>delete</code> as a tool to free up
allocated memory as it does in other languages (like C/C++). <code>delete</code> is just an object Property
removal operation -- nothing more.

<em>enumberable</em>

The enumberable characteristic controls if a property will show up in certain object-property enumerations,
such as the <code>for..in</code> loop. set to <code>false</code> to keep it from showing up in such enumerations,
even though it's still completely accessible. Se to <code>true</code> to keep it present.

All normal user-defined properties are defaulted to enumerable, as this is most commonly what you want. But
if you have a special property you want to hide from enumeration, set it to <code>enumerable:false</code>.

We'll detail this later in our code.

<em>Immutability</em>

It is sometimes desired to make properties or objects that cannot be changed (either by accident or intentionally).
ES5 adds support for handling that in a variety of different nuanced ways.

It's important to npte that <b>all</b> of these approaches create shallow immutability. That is, they affect only
the object and its direct property characteristics. If an object has a reference to another object (array, object, function, etc),
the <i>contents</i> of that object are not affected, and remain mutable.
*/

myImmutableObject.foo; // [1,2,3]
myImmutableObject.foo.push( 4 );
myImmutableObject.foo; // [1,2,3,4]

/*
We assume in this snippet that myImmutableObject is already created and protected as immutable. But,
to also protect the contents of myImmutableObject.foo (which is its own object -- array), you would also
need to make <code>foo</code> immutable, using on or more of the following functionalities.

Note: It is not terribly common to create deeply entrenched immutable objects in JS programs. Special
cases can certainly call for it, but as a general design pattern, if you find yourself wanting to seal or
freeze all your objects, you may want to take a step back and reconsider your program design to be more robust
to potential changes in objects' values.

<em>Object Constant</em>
By combining <code>writable:false</code> and <code>configurable:false</code>, you can essentially create
a constant (cannot be changed, redefined or deleted) as an object property, like:

*/

var myObject = {};

Object.defineProperty( myObject, "FAVOURITE_NUMBER", {
  value: 42,
  writable:false,
  configurable: false

} );

*/

<em>Prevent Extensions</em>

If you want to prevent an object from having new properties added to it, but otherwise leave the rest of the
objects properties alone, call <code>Object.preventExtensions(..):
*/

var myObject = {
  a:2
};

Object.preventExtensions ( myObject );

myObject.b = 3;
myObject.b;  //undefined

/*

In <code>non-strict mode</code>, the creation of <code>b</code> fails silently.
In <code>strict mode</code>, it throws a <code>TypeError</code>.

<em>Seal</em>

<code>Object.seal(..) creates a "sealed" object, which means it takes an existing object and
essentially calls <code>Object.preventExtensions(..)</code> on it, but also marks all its
existing properties as <code>configurable:false</code>

So, not only can you not add any more properties, but you also cannot reconfigure or delete any
existing properties (though you can still modify their values).

<em>Freeze</em>

<code>Object.freeze(..)</code> creates a frozen object, which means it takes an existing object and
essentially calls <code>Object.seal(..)</code> on it, but also marks all "data accessor" properties
as <code>writable:false</code>, so that their values cannot be changed.

This approach is the highest level of immutability that you can attain for an object itself,
as it prevents any changes to the object or to any of its direct properties (though, as mentioned above,
the contents of any referenced other objects are unaffected).

You could "deep freeze" an object by calling <code>Object.freeze(..)</code> on the object, and then recursively
iterating over all objects it references (which would have been unaffected ths far), and calling
<code>Object.freeze(..)</code> on them as well. Be careful, though, as that could affect other (shared) objects
you're not intending to affect.


<em>[[Get]]</em>

Consider:
*/

var myObject = {
    a:2

};

myObject.a  //2

/*
The <code>myObject.a</code> is a property access, but it doesn't just look in <code>myObject</code>
for a property of the name <code>a</code>, as it might seem.

According to the spec, the code above actually performs a <code>[[Get]]</code> operation (kinda like a function
call: <code>[[Get]]())</code> on the <code>myObject</code>. The default built-in <code>[[Get]]())</code> operations
for an object first inspects the object for a property of the requested name, and if it finds it, it will return the
value accordingly.

However, the [[Get]] algorithm define other important behavour if it does not find a property of the requested name.
We will discuss this later.

But one important result of this <code>[[Get]]</code> operation is that if it cannot through any means come up
with a value for the requested property, it instead returns the value <code>undefined</code>.
*/

var myObject = {
  a:2
};

myObject.b; // undefined

/*
This behavour is different from when you reference a variable by their Identifer names. If you reference a
variable that cannot be resolved within the applicable lexical scope look-up, the result is not
<code>undefined</code> as it is for object properties, but instead a <code>ReferenceError</code> is thrown.
*/

var myObject = {
  a: undefined
};

myObject.a; // undefined

myObject.b; // undefined

/*
From a value perspective, there is no difference between these two references -- they both result in
<code>undefined</code>. However, the [[Get]] operation underneath, though subtle at a glance, potentially
performed a bit more "work" for the reference <code>myObject.b</code> than for the reference <code>myObject.a</code>

Inspecting only the value results, you cannot distinguish whether a property exists and holds the explicit
value <code>undefined</code>, or whether the property does not exist and <code>undefined</code> was the default
return value after [[Get]] failed to return something explicitly. However, we will see shortly how you can
distinguish these two scenarios.

<em> [[Put]]</em>
Since there's an internally defined <code>[[Get]]</code> operation for getting a value from a property, it should
be ovious that there is also a default <code>[[Put]]</code> operation.

It may be tempting to thnk that an assignment to a property on an object would just invoke <code>[[Put]]</code>
to set or create that property on the object in question. But the situation is more nuanced than that.

When invoking <code>[[Put]]</code>, how it behaves differs based on a number of factors, including (most impactfully)
whether the property is already present on the object or not.

If the property is present, the <code>[[Put]]</code> algorithm will roughly check:

1. Is the property an accessor descriptor ("Getters & Setters" section below)? <b>If so, call the setter, if any.</b>

2. Is the property a data descriptor with <code>writable</code> of <code>false</code>? <b>If so, silently fail in <code>non-strict mode</code>,
or throw an <code>TypeError</code> in <code>strict mode</code></b>.

3. Otherwise, set the value to the existing property as normal.

If the property is not yet present on the object in question, the <code>[[Put]]</code> operation is even more nuanced
and complex. We will discuss this later in <code>[[Prototype]]</code>

<em>Getters & Setters</em>
The default <code>[[Put]]</code> and <code>[[Get]]</code> operations for objects completely control how values are set to
existing or new properties, or retrived from existing properties, respectively.

Note: Using future/advance capabilities of the language, it may be possible to override the default
<code>[[Put]]</code> and <code>[[Get]]</code> operations for an entire object (not just per property).

ES5 introduced a way to override part of these default operations, not on an object level but a per-property level,
through the use of getters and setters.

Getters are properties which actually call a hidden function to retrive a value.
Setters are properties which actually call a hidden function to set a value.

When you define a property to have either a getter or a setter or both, its definition becomes an "accessor descriptor"
(as opposed to a data descriptor). For accessor-descriptors, the <code>value</code> and <code>writable</code> characteristics
of the descriptor are moot and ignored, and instead JS considers the <code>set</code> and <code>get</code>
characteristics of the property (as well as the <code>configurable</code> and <code>enumberable</code)
*/

var myObject ={
  // define a getter for 'a'
  get a(){
    return 2;
  }

};

Object.defineProperty(
    myObject,       // target
    "b",            // property name
    {
          //define a getter for 'b'
          get: function(){ return this.a * 2 },

          // make sure 'b' shows up as an object property
          enumerable: true
    }
);

myObject.a;   // 2

myObject.b;   // 4

/*
Either through object-literal syntax with <code>get a() {..}</code> or through explicit definition with
<code>defineProperty(..)</code>, in both cases we created a property on the object that actually doesn't
hold a value, but whose access automatically results in a hidden function call to the getter function, with
whatever value it returns being the result of the property access.
*/

var myObject = {
  // define a getter for 'a'
  get a(){
      return 2;
  }
};

myObject.a = 3;

myObject.a;     // 2

/*

Since we only defined a getter for <code>a</code>, if we try to set the value of <code>a</code> later,
the set operation won't throw an error but will just silent throw the assignment away. Even if there
was a valid setter, our custom getter is hard-coded to return only <code>2</code>, so the set opoeration
would be moot.

To make this scenario more sensible, properties should also be defined with setters, which override the
default <code>[[Put]]</code> operation (aka, assignment), per-property, just a you'd expect. You will
almost certainly want to always declare both getter and setter (having only one or the other often leads
to unexpected/surprising behavior):
*/

var myObject = {
    // define a getter for 'a'
    get a(){
      return this._a_;
    },

    // define a setter for 'a'
    set a(val){
      this._a_ = val * 2;

    }

};

myObject.a = 2;

myObject.a      // 4

/*
Note: In this example, we actually store the specified value <code>2</code> of the assignment (<code>[[Put]]</code> operation)
into another variable <code>_a_</code>. The <code>_a_</code> name is purely by convention for this example and implies nothing
special about its behaviour -- it's a normal property like any other.

<em>Existance</em>
We showed earlier that a property access like <code>myObject.a</code> may result in an <code>undefined</code> value if either
the explicit <code>undefined</code> is stored there or the <code>a</code> property doesn't exist at all. So, if the value is
the same in both cases, how else do we distinguish them?

We can ask an object if it has a certain property without asking to get that property's value:
*/

car myObject = {
  a: 2
};

("a" in myObject);                // true
("b" in myObject);                // false

myObject.hasOwnProperty( "a" );   // true
myObject.hasOwnProperty( "b" );   // false

/*

The <code>in</code> operator will check to see if the proprty is <i>in</i> the object, or if it exists at any higher level of the
<code>[[Prototype]]</code> chain traversal. By contrast <code>hasOwnProperty(..)</code> checks to see if only <code>myObject</code>
has the property or not, and will not consult the <code>[[Prototype]]</code> chain. We'll come back to the important differences
between these two operations later.

<code>hasOwnProperty(..)</code> is accessible for all normal objects via delegation to <code>Object.prototype</code>.
But it's possible to create an object that does not link to <code>Object.prototype</code> (via <code>obhject.create(null)</code>).
In this case, a method call like <code>myObject.hasOwnProperty(..)</code> would fail.

In that scenario, a more robust way of performing such a check is <code>Object.prototype.hasOwnProperty.call(myObject,"a"),
which borrows the base <code>hasOwnProperty(..)</code> method and uses explicit <code>this</code> binding to apply it against
our <code>myObject</code>.

Note: The <code>in</code> operator has the apprearance that it will check for the existance of a value inside a
container, but it actually checks for the existance of a property name. This difference is important to note with
respect to arrays, as the temptation to try a check like <code>4 in [2,4,6]</code> is strong, but will not behave
as expected.

<em>Enumeration</em>

The idea of "enumberability" when we looked at the <code>enumberable</code> property descriptor characteristic.
Let's revisit that and examine it in more close detail.
*/

var myObject = {};

Object.defineProperty(
    myObject,
    "a",
    //make 'a' enumerable, as normal
    { enumberable: true, value: 2 }
);

Object.defineProperty(
    myObject,
    "b",
    //make 'b' NON-enumerable
    { enumberable: false, value: 3 }
);

myObject.b;     // 3
("b" in myObject);    // true
myObject.hasOwnProperty( "b" );     // True

// ......

for (var k in myObject){
    console.log( k, myObject[k] );
}

// "a" 2

/*
You'll notice that <code>myObject.b</code> in fact <b>exists</b> and has a accessible value, but it doesn't show
up in a <code>for..in</code> loop (though, it <b>is</b> revealed by the <code>in</code> operator existance check).
That's because "enumberable" bascially means "will be included if the object properties are iterated through".

note: <code>for..in</code> loops applied to arrays can give somewhat unexpected results, in that the enumeration
of an array will include not only all the numeric indices, but also any enumerable properties. It's a good idea to
<code>for..in</code> loops <i>only</i> on objects, and traditional <code>for</code> loops with numeric index iteration
for the values stored in arrays.
*/

var myObject = { };

Object.defineProperty(
    myObject,
    "a",
    //make 'a' enumerable, as normal
    { enumberable: true, value: 2 }
);

Object.defineProperty(
    myObject,
    "b",
    //make 'b' NON-enumerable
    { enumberable: false, value: 3 }
);

myObject.propertyIsEnumberable( "a" );      // True
myObject.propertyIsEnumberable( "b" );      // false

Object.keys( myObject );                    // ["a"]
Object.getOwnPropertyNames( myObject )      // ["a", "b"]
/*

<code>propertyIsEnumberable(..)</code> tests whether the given property name exists directly on the object and is
also <code>enumberable:true</code>

<code>Object.keys(..)</code> returns an array of all enumerable properties, whereas
<code>Object.getOwnPropertyNames( myObject )</code> returns an array of all properties, enumerable or not.

Whereas <code>in</code> vs hasOwnProperty(..) differ in whether they consult the <code>[[Prototype]]</code> chain
or not, <code>Object.keys</code> and <code>Object.getOwnPropertyNames</code> both inspect only the direct
object specified.

There's (currently) no built-in way to get a list of <b>all properties</b> which is the equivalent to what the
<code>in</code> operator test would consult (traversing all properties on the entire [[Prototype]] as explain in chap 5).
You could approimate such utility by recursively traversing the [[Prototype]] chain of an object, and for each level,
capturing the list from <code>Object.keys(..)</code> -- only enumberable properties.

<em>Interation</em>

The <code>for..in</code> loop interates over the list of enumerable properties on an object (including its <code>[[Prototype]] chain).
But what if you instead want to iterate over the valeus?

With numerically-indexed arrays, iterating over values is typically done with a standard <code>for</code> loop, like:
*/

var myArray = [1, 2, 3];

for (var i = 0, i < myArray.length; i++ ){
  console.log( myArray[i] );
}

// 1 2 3

/*

This isn't iterating over the values, though, but iterating over the indices, where you then use the index to
reference the value, as <code>myArray[i]</code>.

ES5 also added serveral iteration helpers for arrays, including <code>forEach(..)</code>, <code>every(..)</code>,
and <code>same(..)</code>. Each of these helpers accepts a function callback to apply to each element in the array,
differing only in how they repectively respond to a return value from the callback.

<code>forEach(..)</code> will iterate over all values in the array, and ignore any callback return values.
<code>every(..)</code> keeps going until the end or callback reutnrs a <code>false</code> (or"falsy") value,
whereas <code>some(..)</code> keeps going until the end or the callback reutnrs a <code>true</code> (or "truthy") value.

These special return values inside <code>every(..)</code> and <code>some(..)</code> acta somewhat like a <code>break</code>
statement inside a normal for loop, in that they stopo the iteration early before it reaches the end.

If you iterate on an object with a for..in loop, you're also getting at the values indirectly, because it's actually iterating
only over hte enumerable properties of the object, leaving you to access the properties manually to get the values.

Note: As contrasted with iterating over an array's indices in a numerically ordered way (for loop or other iterators), the
order of iteration over an object's properties is <b>not guaranteed</b> and may vary between different JS engines.
<b>Do not rely</b> on any observed ordering for anything that requires consistency among enviroments, as any
observed agreement is unreliable.

But what if you want to iterate over the values directly instead of the array indices (or object properties)?
Helpfully, ES6 adds a <code>for of</code> loop syntax for iterating over arrays (and objects, if the object
defines its own custom iterator):
*/

var myArray = [];

for (var v of myArray){
    console.log(v);

}
// 1
// 2
// 3

/*
The <code>for..of</code> loop ask for an iterator object (from a default internal function known as <code>@@iterator</code>)
in spec-speak) of the thing to be iterated, and the loop then iterates over the successive return values from calling that
iterators object's <code>next()</code> method, once for each loop interation.

Arrays have built-in @@iterator, so for..of works easily on them, as shown. But let's manually iterate the array, using the built-in
@@iterator, to see how it works:
*/

var myArray = [1, 2, 3 ];

var it = myArray[Symbol.iterator]();

it.next();  // { value:1, done: false }
it.next();  // { value:2, done: false }
it.next();  // { value:3, done: false }
it.next();  // { done: true}

/*
Note: We get at the @@iterator  internal property of an object using ES6 <code>Symbol</code>:
<code>Symbol.iterator</code>. We briefly mentioned <code>Symbol</code> semantics earlier in the chapeter ("Computed Property Names"),
so the same reasoning applies here. You'll always want to reference such special properties by <code>Symbol</code> names reference
instead of by the special values it may hold. Also, despite the names implications, @@iterator is <b>not the iterator object</b> itself,
but a <b>function that returns</b> the iterator object -- an important detail.

As the above snippet reveals, the return value from an iterator<code>next()</code> call is an object of the forms
<code>{value: .. , done: ..}</code>, where the value is the current iteraction value, and done is a boolean that
indicates if there's more to iterate.

It is possible to define your own default @@iterator for any object that you care to iterate over. For example:
*/

var myObject = {};

Object.defineProperty( myObject, Symbol.iterator, {
	enumerable: false,
	writable: false,
	configurable: true,
	value: function() {
		var o = this;
		var idx = 0;
		var ks = Object.keys( o );
		return {
			next: function() {
				return {
					value: o[ks[idx++]],
					done: (idx > ks.length)
				};
			}
		};
	}
} );

// iterte 'myObject' manually
var it = myObject[Symbol.iterator]();
it.next();  // { value:2, done:false }
it.next();  // { value:3, done:false }
it.next();  // { done: True }

// iterate 'myObject' with 'for..of'
for (var v of myObject) {
	console.log( v );
}
// 2
// 3

/*
Note: We used Object.defineProperty(..) to define our custom @@iterator (mostly so we could make it non-enumerable),
but using the <code>Symbol</code> as a <i>computed property name</i> (covered ealier in this chapter), we could have
declared it directly, like <code>var myObject = { a:2, b:3, [Symbol.iterator]:function(){}/* .. *[/] } }</code>.

Each time the for..of loop calls next() on myObject's iterator object, the internal pointer will advance and return
back the next value from the object's properties list (see previous note about iteration ordering on an object
properties/values).

The iteration we just demonstrated is a simple value-by-value iteration, but you can of course define arbitrarily
complex iterations for your custom data stuctures,as you see fit. Custom iterators combined with ES6's forr..of loop
are a powerful new syntactic tool for manipulating user-defined objects.

For example, a list of <code>Pixel</code> objects (with x and y coordinate values) could decide to order it
iteration based on linear distance from the (0,0) origin, or filter out points that are "too far away", etc.
As long as your iterator returns the expected {value: .. } reutrn values from next() calls, and a { done: true }
after te iteration is complete, ES6's for..of can iterate over it.

In fact you can even generate "infinite" iterators which never "finish" and always return a new value
(such as a random numberm, an incremented value, a unique identifer, etc) though you probably will not use
such iterators with an unbounded for..of loop, as it would never end and would hang your program.
*/

var randoms = {
    [Symbol.iterator]: function () {
          return {
                  next: function() {
                        return { value: Math.random() };

                  }

          };

    }

};

var randoms_pool = [];
for (var n of randoms) {
      randoms_pool.push( n );

      // don't proceed unbounded
      if (randoms_pool.length ===100) break;

}
/*
This iterator will generate random numbers "forever", so we're careful to only pull out 100 values so our program
doesn't hang.


</script>
<head>
<html>
